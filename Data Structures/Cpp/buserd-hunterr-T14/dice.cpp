/* diceroll.cpp created for CSC 236 Data Structures at Berea College
Course: CSC 236 Data Structures
Name: Dylan S. Buser and Rebeccah Hunter
Assignment T14: This program is supposed to roll a pair of dice however many times the 
user tells it to. 

Purpose: The larger more metaphysical goal of this assignment is to build our 
skillset in C++. However the technical objective is to create a program in which 
a pair of dice can be rolled many times. The program should account for a small
amount of rolls as well as an overly large amount of rolls (such as 2,000). 
This is to help us in our understanding of programs being adaptable in the
information that they handle, both within the system or from the user.
*/

#include <iostream>
#include <ctime>
#include <cmath>
#include <cstdlib>
#include <string>
using namespace std;

//---------------------------------------------------------------------
// Program illustrating use of C++ classes called Dice and RandGen
//---------------------------------------------------------------------
class RandGen
{
  public:
    RandGen();                          // set seed for all instances
    int RandInt(int max = RAND_MAX);     // returns int in [0..max)
    int RandInt(int low, int max);      // returns int in [low..max]
    double RandReal();                  // returns double in [0..1)
    double RandReal(double low, double max); // range [low..max]

    static void SetSeed(int seed);      // static (per class) seed set
  private:
    static int ourInitialized_;          // for 'per-class' initialization
}; //a semi-colon must end every class declaration.


class Dice
{
  public:
  	Dice(); 				// default constructor assumes a 6-sided die.
    Dice(int sides);        // constructor for any size dice
    int Roll();             // return the random roll of the die
    int NumSides() const;   // how many sides this die has
    int NumRolls() const;   // # times this die rolled

  private:
    int myRollCount_;        // # times die rolled
    int mySides_;            // # sides on die
}; //a semi colon must end every class declaration.

//---------------------------------------------------------------------
// main begins here
//---------------------------------------------------------------------

int main()
{
    const int SCALEFACTOR = 75;
    const int start=1;
    const int stop=12;

    int storeroll[13]; // this is an array declaration for an array of 12 integers
    storeroll[0]=0;
    storeroll[1]=0;
    storeroll[2]=0;
    storeroll[3]=0;// this will remain unused, but we can initialize it.
    storeroll[4]=0;
    storeroll[5]=0;
    storeroll[6]=0;
    storeroll[7]=0;
    storeroll[8]=0;
    storeroll[9]=0;
    storeroll[10]=0;
    storeroll[11]=0;
    storeroll[12]=0;
    int storage_number = 0;
   
    //int storeroll2[13];
    //storeroll2[0] = 0;
    int user_var;
    cout << "How many times would you like to roll these dice?";
    cin >> user_var;
    int loopcount = user_var;

    Dice tom;              // make a six-sided die
    Dice jerry;

    tom.Roll();  //For debugging purposes, the same number will be generated by EVERY SINGLE first roll.
    //So, unless you want the same number for each first roll, we must throw away the first roll.
    //which we do by ignoring the first roll and not storing it or printing it out.

    cout << "This loop displays "<<user_var-start+1 <<" rolls of a 6-sided dice:\n" << endl;
    for (loopcount=start; loopcount<=user_var; loopcount++) 
    {   //adds the two dice values together
        int number_rolled=tom.Roll() + jerry.Roll();
        //adds 1 to the count for each individual number each time it is rolled.
        storeroll[number_rolled-1]++; 
        
        storage_number = storeroll[number_rolled-1];
        //Prints out the rolls and their counts
        //cout << "Roll " <<loopcount<< " for die 1 and 2 is " << number_rolled << "."<< endl;
        //storeroll2[loopcount]=jerry.Roll();
        //cout << "Roll " <<loopcount<< " for die 2 is " << storeroll2[loopcount] << "."<< endl;
        //cout << "roll count for " << number_rolled << " = "<< storage_number << "\n";
    }
    
    
    // These are all of the variables needed for a loop
    int dice_value = 2;
    //int store_roll_index = 0;
    int start2 = 1;
    int end2 = 11;
    int star_cout = 1;
    //int loopcount3 = 1;
    
    if (user_var < SCALEFACTOR)
    /*If and else statements to handle rolls of less than 75 or greater than 75.
    if the number is less, the for loop executes below naturally. If it is greater
    than 75 it executes the for loop, but divides the resulting number of rolls
    for each number by the ratio attained above that depends on the user's input*/
    
    // DO THE SCALING FACTOR
    {
        
        for (int loopcount2 = start2; loopcount2<=end2; loopcount2++)
        {   
            //cout << "print things";
            // This section creates a for loop that will add a * for each time the number of the dice was roled
            //int sec_loopcsatart = 1;
            //cout << store_roll_index;
            //string num_stars = "";
            
            cout << "\n"<< dice_value << ":";
            cout << string(storeroll[star_cout], '*');
            cout << "\n" << "        (" << storeroll[star_cout] <<")";
            //cout << "print things";
            dice_value++;
            star_cout++;
        }
        //storeroll[0]=tom.Roll();
        //cout << storeroll[0];
        cout << "\nI done did rolled it " << tom.NumRolls()-1 << " times.\n" << endl;
    
        return 0;
    }
    
    else 
    {
        
        int scaling_factor = 0;
        // while count < 11: compare storeroll[i] to storeroll[i+1]
        // if storeroll[i]> scaling_factor  then scaling_f = storoll[i]      i++
        // else, i++
        int scaling_end = 13;
        
        int scaling_start = 2;
        for (int a_new_start = scaling_start; a_new_start< scaling_end; a_new_start++)
        {
            //cout <<" Taco bell: " << scaling_start;
            if (storeroll[a_new_start] > scaling_factor)
            {
                scaling_factor = storeroll[a_new_start];
            }
            
            //cout<< "The Scaling Factor is:  "<<scaling_factor<< "\n";
            
        }
        
         //cout << SCALEFACTOR<<"\n";
         //cout << scaling_factor<< "\n";

        for (int loopcount2 = start2; loopcount2<=end2; loopcount2++)
        {   
            //cout << "print things";
            // This section creates a for loop that will add a * for each time the number of the dice was roled
            //int sec_loopcsatart = 1;
            //cout << store_roll_index;
            //string num_stars = "";
            //cout << storeroll[star_cout];
            
            //(756/75) + 1 = 11	<-- each asterisk represents 11 rolls
            //756/11 = 68		<-- there are 68 asterisks for 756 rolls
            
            cout << "\n"<< dice_value << " rolled:";
            cout << string((storeroll[star_cout])/SCALEFACTOR, '*');
            cout << "\n" << "        (" << storeroll[star_cout] <<") rolls";
            //cout << "print things";
            dice_value++;
            star_cout++;
        }
        //storeroll[0]=tom.Roll();
        //cout << storeroll[0];
        cout << "\nI done did rolled it " << tom.NumRolls()-1 << " times.\n" << endl;
    
        return 0;
    }
}

//---------------------------------------------------------------------
// RandGen class functions begin here
//---------------------------------------------------------------------

int RandGen::ourInitialized_ = 0;

void RandGen::SetSeed(int seed)
// postcondition: system srand() used to initialize seed
//                once per program (This is a static function)
{
    if (0 == ourInitialized_)
    {
    ourInitialized_ = 1;   // only call srand once
	srand(seed);          // randomize
    }
}


RandGen::RandGen()
// postcondition: system srand() used to initialize seed
//                once per program
{
    if (0 == ourInitialized_)
    {
    	ourInitialized_ = 1;          // only call srand once
        srand(unsigned(time(0)));    // randomize
    }
}

int RandGen::RandInt(int max)
// precondition: max > 0
// postcondition: returns int in [0..max)
{
    return int(RandReal() * max);
}

int RandGen::RandInt(int low, int max)
// precondition: low <= max
// postcondition: returns int in [low..max]
{
    return low + RandInt(max-low+1);
}

double RandGen::RandReal()
// postcondition: returns double in [0..1)
{
    return rand() / (double(RAND_MAX) + 1);
}

double RandGen::RandReal(double low, double high)
{
    double width = fabs(high-low);
    double thelow = low < high ? low : high;
    return RandReal()*width + thelow;
}

//---------------------------------------------------------------------
// Dice class functions begin here
//---------------------------------------------------------------------

Dice::Dice()//Default is to assume a six sided die.
// postcondition: all private fields initialized
{
    myRollCount_ = 0;
    mySides_ = 6;
}


Dice::Dice(int sides)
// postcondition: all private fields initialized
{
    myRollCount_ = 0;
    mySides_ = sides;
}

int Dice::Roll()
// postcondition: number of rolls updated
//                random 'die' roll returned
{
    RandGen gen;    // random number generator

    myRollCount_= myRollCount_ + 1;         // update # of times die rolled
    return gen.RandInt(1,mySides_);        // in range [1..mySides_]
}

int Dice::NumSides() const
// postcondition: return # of sides of die
{
    return mySides_;
}

int Dice::NumRolls() const
// postcondition: return # of times die has been rolled
{
    return myRollCount_;
}

